---
title: "Dependently Typed Systems Language"
---

# Notes for a dependently typed systems language

I wish I could give you a name for it, but in this I fail.

Ideas are welcome.

## Assumptions about you

I am assuming that you have a decent understanding of dependent types, and type theory in general.

I will be using a Rust style syntax for the pseudocode in this document.
If anything strays far from Rust, I will attempt to explan my reasoning.

## Inspirations

Several things inspired me to make this, with the most obvious being Rust for the flavor, and bringing strong types that otherwise would be trapped in academia to a popular systems languages.
And of course the various dependently typed languages; Rocq, Agda, Idris, and Lean.

I also have been involved with the community for Faiface's [Par](https://github.com/faiface/par-lang) which has given me many ideas that have helped to develop this page.
In some ways, if Par is linear logic, I think this this is something in the vein of ultrafinitism lol.

Overall my goals for this language are to be able to describe as many low level processes within the type system, without sacrificing any power.

## Types

I think for a usable systems language you need to have complete control over the layout of memory.
For this reason, I beleive that it is correct for the Kind of Types to be indexed by the size of the memory it occupies.
As such, Types of Types are indicated as `Type(n)` where `n` is a natural number.
If possible I think that variable sizes should be expressed using the same type of numbers as is typically used for programming, so likely it will be an equivalent to Rust's `usize`, where `usize: Type(PTR_SIZE)`

The final type system will probably also need to worry about alignment of types,
but every time I try to think about the math to make alignment work,
I lost track of my second and third braincell, so I will be ignoring that for now.

### Linear Types

Unless more is known about a type, it is assumed to be linear.
This allows us to use linear type's ability to express ownership and provide guarentees about the usage of various resources.

When a value is used in a type declaration, it **does not** consume the value, allowing types to depend on linear values.

### Structural Typing

Types are going to be structural. I think that this is best for a systems language as it allows flexibility in various things.

### Structs and Records

Unlike most similar languages, I think that it is correct to have multiple ways to package data together, as follows:

Structs are represented linearly in memory such that `struct {a: u8, b: u8, c: u8}` is identical to `struct {fido: u8, jimbo: struct {size: u8, age: u8}}`.
I will likely also include a way to transmute between such types freely.

Records are more similar to Rust's structs, where size and layout are decided by what will be the most efficient.

Mathematically, the two types are trivially isomorphic, but structs will be useful for many system tasks.

#### Size

The size of a struct is the sum of the sizes of it's component ie if `T: Type(n)` and `U: Type(m)` then `struct {a0: T, a1: U}: Type(n + m)`

#### Linearity

Structs and Records are linear if and only if any of its members are linear values

### Enumerated types

The language should include a simple syntax for tagged unions.

I don't know what I want to call these, as I have never really loved any of the options, so I will just borrow enum from rust for now.
Names I have considered, but of which I don't love any are:
- enum
- variant
- either
- union (wouldn't actually mind this one, except thay it harkens to C's untagged unions)


In dependent style, there should probably be options to have different constructors produce different types, but I am not certain on the syntax. It is WIP.

```
def Bool: Type(1) = enum {
  true,
  false,
}
```
#### Size

An enum type will be one `PTR_SIZE` larger than the largest constructor's type.

#### Linearity

An enum is treated linearly if any of its constructors are linear.

### Functions

There are no Lambda expressions in the core language, though they can be recovered somewhat using syntax sugar.

Essentially, functions can only be defined at the top level.
This allows them to have a fixed size, as we are requiring.

The function pointers will be the same size as `usize`.

This also prevents partial application, but again we can work around this in some cases.

The syntax for a function pointer is `(a: A, b: B, ...) -> R`

Closures are of type `record { self_type :0 Type(_), call: (self: self_type, args...) -> R, self: self_type }`
where the size of the context is usually infered and can be abreviated as `(args...) => R`.

#### Size

Functions will be `PTR_SIZE` as they are effectivly just function pointers.

Closures are sized according to the record rules.

#### Linearity

Function pointers are non-linear, and can be used any number of times.

Closures are non-linear, as they contain a value `self` that is not known to be nonlinear.

### Box Types

This is simple. It basically is a heap allocated value that allows you to fit a larger variable in a smaller one.

#### Size

`T: Type(n) ⊦ Box(T): Type(PTR_SIZE)`

#### Linearity

Box is linear if its inner type is linear

### References

I would love to have rust style references, which allow shared and unique access to objects.
I haven't worked out the specifics of how lifetimes would work with the other types.

One think I have played with is having mutable references with both an `in` type and an `out` type.
For example, an initializer for a type `T: Type(n)` could be of type `(self: &mut(Unit(n), T)->Unit` (if `Unit(n): Type(n)`)

## Zero Quantified definitions

This is somthing that I think is useful that I am borrowing from Quantified Type Theory.
I only really have been exposed to this via a brief exploration with idris, so my knowledge is limited.

When a variable is declared using `:0` in stead of the usual `:` this means that the variable is only usable within types.

I think it might be needed to have a higher universe called Kind that is zero quantified, such that `Type(n):0 Kind`

## Recursion, Loops and Totality

I do not know if we should aim for a total language or not.
The language nerd in me says it should be total.
The systems programmer says we probably are going to need non-termination often enough to justify having our language inconsistent as a logic.

Most practical languages are turing complete, but I have come to see this as a less than ideal situation.
It is possible to have a powerful enough termination checker to catch most real world programs, and for the few times when that is not possible, we can easily add a well defiend escape hatch.

One concern that I see with having a non total dependently typed language is the potential for non-terminating type checking.
In practice, this in not a huge concern for me, as many programming language have type systems which themselves are turing complete if not artifically restricted (rust and c++ both are examples).
As such, I don't think this is a good enough reason to insist on totality, even though I do lean that way.

## Subtypes

I like subtyping, but it does complecate some things. I would want subtyping of enums, and possibly some records, where elements can be trivially dropped.

Here are subtyping rules I have considered:
- `record {A: record {XYZ}, Xs} :> record {XYZ, Xs}` where XYZ doesn't have any names in common with Xs.
  Note a special case where `record {A: record {}, Xs} :> record {Xs}`
- `T :> enum { default(T) }`
  This allows defining `Result(T, E) = enum {default(T), error(E)}` which makes wrapping a result automatic.
- `record {self: T, Xs} :> T` Note that `Xs` must all be dropable.
  This is probably most usful in expressing subtypes, as self can be a type, and Xs is ignorable in type annotations.

The main reasons I would like subtyping is to allow certain seemless translations between types, without making it completely unpredictable and arcane (looking at you C++).

### Methods

A record with a self value can be used like a dynamic object as follows.

The print function is ficticious in the following example, and coerrces it's argument to a usize.
It also assumes that usize can be copied.

```

dec acc : record {
  self: usize,
  add: (usize, usize) -> usize,
  mul: (usize, usize) -> usize,
}

print(acc); // 0
acc.add(10);
print(acc); //10
acc.mul(11);
print(acc); //110

```

I think that there will be circumstances where you want the argument type to change, so the following is also valid.

```

dec door : record {
  open_door:0 Type(_),
  closed_door:0 Type(_),

  self: open_door,

  open: (closed_door) -> open_door,
  close: (open_door) -> closed_door
}

```

This allows state machines to be encoded in a type safe way, without requiring Rust style Zero-Sized-Types.

I quite like Par's arrow syntax for calling functions in series, so I will likely have something like this as well.

```
def fibonacci(n: usize): usize {
  if n <= 1 {
    1
  } else {
    fibonacci(n - 1) + fibonacci(n - 2) // Might not work in final version. See recursion and loops
  }
}

def n: usize = 10;
n->fibonacci();
print(n) // 55
```

#### Special Methods

The following methods have special behavior
- `drop: (self : self_type) -> Unit`
  deletes the value
- `copy: (self : self_type) -> Pair(self_type, self_type)`
  copies the value
- `call: (self : self_type, args...) -> R`
  allows calling the record similar to a function of type `(args...) -> R`

## Unsafe / Escape Hatches

As this is designed to be a systems language, it will require some way to assert hardware properties and guarentees.

I don't know the best way to implement this, but I expect that mmuch of it will come from asserting Axioms, and allowing transmutation.

The code should be able to unsafely transmute between any types of the same size.

Roughly speaking: `transmute: (n: usize, T0: Type(n), T1: Type(n), t: T0) T1` ignoring whatever syntax I come up with for unsafe.

## Usage Examples

The following are example that I think woudl be at least close to programs in the final language.

### GPIO Pins
This is how I would expect a blinky example to look like on a Arduino or the like.
Don't worry too much about the IO type. It is mostly fictional for now.
```
use std::units::milliseconds;

def start(io: IO) {
  let led = io.pin(13);

  loop { // loop might not be in the language... See Recursion and loops
    led.on();
    io.delay(500->milliseconds());
    led.off();
    io.delay(500->milliseconds());
  }
}
```

## Other things

There are other things that I would like, but I do not know how to make them fit.

Here are some things I have stewed with:

- Some way of saying "This process never returns to the caller".
  Like Bottom in linear logic, and `?` in Par.
- I haven't fully decided how to handle allocation. I would like slightly more control than rust allows without needing to micromanage.
- I am not sure how to represent equality in the type system.
  Most dependent type systems define it inductively, but That doesn't **really** give me intuition for how to encode an Identity type.
  One thing I am fairly certain is that Uniqueness of Identity Proofs should probably hold: `(n : usize, T: Type(n), t0: T, p: Eq(t0, t0)) -> Eq(p, refl(p))`

## Conclusion

I am happy to hear any ideas, or edge cases I havent considered yet.
I don't have any prefered way to contact me for now, but if you leave a comment on whatever platform you found this on, I should probably see it.
I do not know if I will ever make this language. It is mostly a fever dream of a language nerd for now, and I work a full time job and half a ½ million hobbies or so, so it carries no guarentees.

This page will be updated as I remember things I have thought of, and come up with new ideas. 
